<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>
    hoarderMediaOS
    </title>
    <link rel="stylesheet" href="./style.css">
</head>
<body>
<div id="content">
<h1>hoarderMediaOS</h1>

<p>This readme previously contained a tutorial. It is now found
<a href="https://github.com/cmotc/hoarderMediaOS/blob/master/TUTORIAL.md">at TUTORIAL.md</a>
While it's content is largely still relevant, the version of this project it
refers to has now changed. Look into the includes/*.mk files for more examples.</p>

<p>This wholly unnecessary and abusive concoction of Docker containers, Makefiles,
and so-called "auto" scripts is the latest and most successful of my attempts to
create my own custom Debian-based Live Media. At this point I basically have to
acknowledge, it's been pretty much entirely for the hell of it. But it's been
educational too. I suppose that was a little by accident, thus the tone of the
tutorial linked above.</p>

<p>So, basically what I did was treated make like a control panel, in order to bend
docker to do my bidding, which happened to be running the priveleged operation
of building an iso with Debian's live-build inside of a container. The overall
rationale for this choice is mostly covered in the tutorial. There has, however
emerged some errata as this configuration has come to do more things.</p>

<h2>There is a couple of configuration files you need to pay attention to.</h2>

<p>The first of which is paths.sh. This is just a place to store information that
helps retrieve copies of the built iso from a remote build server, specifically
the ssh username/hostname to use, and the folder from which to retrieve the
completed images. An example paths.sh might be</p>

<pre><code>    export user_name="dev"
    export host_name="dev"
    export dev_path="/home/$user_name/Projects/hoardermediaos"
</code></pre>

<p>The next new configuration file is auto/common. As it's name suggests, it's a
set of global variables used by the other scripts in auto/. It is generated
inside the container, so changing it outside the container will have no effect,
instead it exists to ensure that some static settings generated inside the
container can be used by the parts that happen outside the container,
specifically auto/copy, auto/pull, and auto/release. Speaking of which...</p>

<h2>In this repository, auto/ doesn't just house auto scripts anymore.</h2>

<p>In addition to the actual auto scripts, several new scripts have been added.
They are only related insofar as the exist to bridge gaps between the Docker
parts of the build and the machine hosting it, and to automate retrieval from
the remote build server. I guess I'm also planning on one that may be used to
set up an encrypted persistence volume as well, resulting in a LiveUSB-only
edition which would be pretty cool too. But focusing on the ones that exist so
far:</p>

<ul>
<li>auto/copy: triggered by running make docker-copy. This is used to copy the
finished images and accompanying metadata from the build container to the
host machine for further processing. It copies the newly-generated
auto/common file, from the build container reads in it's contents, and copies
the images.</li>
<li>auto/pull: triggered by running make pull. allows you to pre-configure the
system to retrieve build artifacts from a build server located elsewhere.
If you're building locally, you will not need this. It's configured using a
paths.sh file in the project folder's root, which it loads before anything
else. Then it loads auto/common by retrieving it from the build server,
overriding local defaults, and finally copies the build artifacts.</li>
<li>auto/release: triggered by running make release. generates the necessary
files to make a release of the images available for download via github
releases. In order to feel less like a jerk about uploading a bunch of 1.3gb
images to a website I use for free, it also generates a torrent file.
<strong>USE THE TORRENT TO DOWNLOAD THE IMAGE</strong>. It is a web-seeded torrent, if no
torrent peers are available it will be able to use the web source to
download instead.</li>
</ul>

<p>Planned:</p>

<ul>
<li>auto/persistence: triggered by running make persistence. This will configure
a persistence partition on your LiveUSB with appropriate encryption.</li>
<li>auto/download: triggered by running make download. This will start a torrent
client to download the image in the background, wait for the image to be
downloaded, verify it's signature and sum, and display readable results.</li>
</ul>

<h2>Part of this is about getting computers on and off my network to communicate efficiently.</h2>

<p>Continuing in the spirit of "Anyone can do it, if they want to," my laptop is
not new or fast. It's actually pretty old and slow, hence the wierd mix of
software I prefer. But my desktop can build this LiveCD in about 35 minutes.
So when I push something from my laptop, the desktop picks up the change and
builds it, I retrieve it, and sign it on my laptop. This process still has room
for improvement but it's getting to the point where it's downright sensible.
Eventually, I shall start tying together all the little, apparently disparate
hobby projects I've been working on, when enough of them are in the CI to make
the point. Anybody can start customizing their OS install media with a little
effort.</p>

<p>To help paint a picture, here are the most significant of the repositories
related to my home networking project:</p>

<ul>
<li>Router OS <a href="https://github.com/eyedeekay/lede-docker">lede-docker</a></li>
<li>Xen Dom0 <a href="https://github.com/eyedeekay/kloster">kloster</a></li>
<li>Desktop/P2P OS <a href="https://github.com/eyedeekay/hoardermediaos">hoardermediaos</a></li>
<li>Containerized apt-cacher-ng <a href="https://github.com/eyedeekay/hoardercache-docker">hoardercache-docker</a></li>
<li>Repository frontend creator for static web hosts <a href="https://github.com/eyedeekay/apt-now">apt-now</a></li>
<li>Tablet OS image Configuration <a href="https://github.com/eyedeekay/imgmaker">imgmaker</a></li>
</ul>
</div>
<div id="content">
<h1>How I decided to continuously remaster my own Debian Variant without, like, totally meaning to.</h1>

<p><a href="https://github.com/cmotc/hoarderMediaOS/blob/master/Tutorial/HOWTO.0.INTRODUCTION.md">Standalone Chapter</a></p>

<p>OK, this thing is a work in progress, so bear with me while I do it, but here's
what I'm attempting. I have spent alot of time refining my home PC's
configuration based on defaults in the Debian installer, and the packages
themselves, and I've been pretty successful at it. But it's an ongoing process,
and sometimes, you bork something and you've got to reinstall. Which means that
you've got to reproduce all that configuration and start over, which kind of
sucks. There are many ways to approach this, and what this readme is going to
amount to is simply an example of but one way of doing things(With some
variations, because some of the things that Docker can allow you to do are
awesome). I wanted a lightweight media-center OS for retro gaming that could
double as a Media Server, I totally uncreatively called it hoarderMediaOS, and
now it's a reasonably easy to reproduce procedure and I hope it's helpful. It's
based on Unstable, though, so it's might become outdated at any moment. I'm
going to keep doing it though, so I'll probably notice if it stops working.</p>

<h2>Who this tutorial is targeted at</h2>

<p>Enthusiastic Amateurs! People who like Debian/Ubuntu based distributions for
their excellent stability and diligent community, but who don't necessarily
want to use one of the regular desktop environments in the default
configuration. Ricers, datahoarders, and hobbyists who would rather use Debian
than Arch or Gentoo. Anyone who uses their home computer for experimentation.
The point of this tutorial is that <strong>anyone</strong> can learn to continuously
customize their Linux configuration if they wish to, <strong>anyone</strong>, even a solitary
hobbyist with no significant organizational resources.</p>

<p><strong>Is it a distro?</strong></p>

<p><strong>God I hope not.</strong> I'm not a person who really likes to deal in opinion. I
deleted my whole blog because I felt obligated to be personal. Unfortunately,
I have an opinion. I'm opinionated. And it's my opinion that it's too easy for
people to consider any installable media that gets redistributed equal to a
recognizable distro. It's just not. Tiny distros can be <strong>amazing</strong>, I loved
CrunchBang and felt genuine sadness when corenominal gave it up, and genuine
excitement for BunsenLabs and Crunchbang++. I love Linux Mint and think
Cinnamon will ease many people's Dad's transition into using GNU/Linux from
Windows when they start to get pissed off about Windows 10 serving them ads
all the damn time. But there are caveats to using these tiny niche distros. You
have to take matters into your own hands at times, even things that are second
nature to you or me, might not be obvious to a first-time Mint user, even things
as simple as being able to use AskUbuntu to get help. It takes a while to learn
to translate the Arch wiki.</p>

<p>Depending on their complexity, they may also configure 3rd-party repositorys.
<strong>Please consider that in the most serious of terms</strong>. If they configured a
third-party repository, they have probably used it to install something. That
application was installed from that third-party repository because it's probably
experimental and <strong>not ready to be held to the standards of an official Debian</strong>
<strong>package</strong>. That doesn't mean it's bad. Lots of software from third-party
repositories is <strong>awesome</strong> but using third party software is kind of a big
decision.</p>

<p>It is my opinion that there ought to be a clearer way to consider these two
types of distros specifically. Maybe something like "Upstream Distro" and
"Enthusiast Distro" as a place to instigate a lexical split, and make clear the
advantages, disadvantages, and implications of each. Using an "Enthusiast
Distro" is fun, and creating one is fun. Sharing them ought to be fun, too.
I would be more comfortable sharing my own "Enthusiast Distro" if I were sure
people understood, I'm just one guy, depending on the work of thousands, I think
building riced install media is fun, and that's <strong>it</strong>.</p>

<h2>What am I actually going to talk about?</h2>

<p>live-build, docker, sid, make. Specifically, I'm going to teach you how to use
these tools to continuously package your own personal configuration of Debian
as an iso that can be used to create install media, just like the regular Debian
LiveCD's.</p>

<h2>What are you going to need?</h2>

<p>Either Debian unstable(sid), Devuan unstable(ceres) or any distribution
supporting Docker and coming configured with the Docker Hub.</p>

<p><strong>On that note, Dependencies</strong></p>

<pre><code>    Debian Sid/Devuan Ceres
    =======================
    sudo apt-get install live-build debootstrap make
    optionally,
    sudo apt-get install git docker.io
</code></pre>

<p>or install docker per your distribution's instructions or from source. Docker
will use the debian:sid container as a base. A git repository or a git hosting
service will also be helpful if you want to backup and share your configuration.</p>
</div>
<div id="content">
<h1>Step Zero: A crash course in live-build</h1>

<p><a href="https://github.com/cmotc/hoarderMediaOS/blob/master/Tutorial/HOWTO.1.LIVEBUILD.md">Standalone Chapter</a></p>

<h2>See also:</h2>

<ul>
<li><a href="https://debian-live.alioth.debian.org/live-manual/stable/manual/html/live-manual.en.html#178">Debian live systems manual, First Steps</a></li>
</ul>

<p>All in all, live-build is a pretty simple, straightforward, regular tool to use.
For most purposes, it will come down to the use of three commands. These
commands are:</p>

<ol>
<li>lb config</li>
<li>lb build</li>
<li>lb clean</li>
</ol>

<p>If you wanted to create the absolute bare-minimum default liveCD that live-build
will generate, you could simply run</p>

<pre><code>    lb config &amp;&amp; sudo lb build
</code></pre>

<p>in an empty directory and in a few minutes, you'd have a basic liveCD. However,
it wouldn't be very useful. This CD won't have an X server, or many of the
applications desktop Linux users may have come to take for granted. Fortunately,
it's pretty easy to turn this into a base system. Just add a desktop metapackage
to the configuration, in between the two commands.</p>

<pre><code>    lb config
    echo 'budgie-desktop' &gt;&gt; config/packages/live.list.chroot
    sudo lb build
</code></pre>

<p>This will get you a live system with the excellent budgie desktop. In doing so,
it will many packages on the liveCD that budgie-desktop depends on.</p>
</div>
<div id="content">
<h1>Step One: Set up your own caching proxy for apt(You'll be much better off)</h1>

<p><a href="https://github.com/cmotc/hoarderMediaOS/blob/master/Tutorial/HOWTO.2.APTCACHERNG.md">Standalone Chapter</a></p>

<h2>See-also:</h2>

<ul>
<li><a href="https://www.unix-ag.uni-kl.de/~bloch/acng/">apt-cacher-ng Homepage and Configuration Instructions</a></li>
<li><a href="https://docs.docker.com/engine/examples/apt-cacher-ng/">apt-cacher-ng dockerized</a></li>
</ul>

<p>After running debootstrap fourty or fifty times, you might be thinking "This
wasn't so bad the first time, but this is definitely not an instantaneous thing.
Sure would be nice to mirror these somewhere immediately nearby." And you might
try and search for how to set up a mirror and get discouraged by how large it
is. That's what apt-cacher-ng is for. apt-cacher-ng is a caching proxy that
is used to cache packages downloaded by package managers in your Linux
distributions. It will only cache the packages you request from it, so it's only
as big as it needs to be, and it can be used to bootstrap your live disk and
your installation, which will save you much bandwidth. And it's super easy to
configure, too. If you're using only the main Debian repositories especially,
it should just work, right out of the box, and if all your third-party
repositories are using plain http, they can be used through apt-cacher-ng
transparently, although it will not cache those packages unless it is configured
to. It seems like there are three main situations where you might want to make a
change to how apt-cacher-ng works by default.</p>

<p><strong>Allow https repositories to CONNECT through apt-cacher-ng</strong></p>

<p>Increasingly, some software sources are making their repositories available only
by way of https. This is probably not like, super necessary, as it will do
little to obscure the nature of the traffic, but I think it's nice in general.
But it presents a problem if you use apt-cacher-ng. It will not connect to https
repositories by default. In order to allow it to, you can simply uncomment this
line:</p>

<pre><code>    # PassThroughPattern: .* # this would allow CONNECT to everything
</code></pre>

<p>so it looks like this.</p>

<pre><code>    PassThroughPattern: .* # this would allow CONNECT to everything
</code></pre>

<p>and voila! You can now use https repositories through your apt-cacher-ng
instance, however it will not cache those packages yet.</p>

<p><strong>Third-party Repository using plain http</strong></p>

<p>If you want to cache packages from a thrid-party repository using apt-cacher-ng,
such as the Devuan repository, then you will need to create a backend for that
package and then make apt-cacher-ng aware of that backend. A backend is simply
a file containing the url of the repository you want to use. So to create a
backend for Devuan or any other repository available over plain http, one need
only:</p>

<pre><code>    echo "http://packages.devuan.org/merged" | sudo tee /etc/apt-cacher-ng/backends_devuan
</code></pre>

<p>Then, in order to make apt-cacher-ng aware of it's existence, you need to
configure is in /etc/apt-cacher-ng/acng.conf. In this configuration line, you'll
remap the Devuan mirror to a new name and tell it to use the backends_devuan
file.</p>

<pre><code>    Remap-devrep: file:devuan_mirror /merged ; file:backends_devuan # Devuan Archives
</code></pre>

<p>Next time you start your apt-cacher-ng instance, it will know to cache Devuan
packages.</p>

<p><strong>Third-party Repository caching using https</strong></p>

<p>It would also be nice to cache https repositories, and you can do just that with
apt-cacher-ng. It's pretty similar to using it with plain http, a backend is
still just as mu</p>

<pre><code>    echo "https://repo.lngserv.ru/debian" | tee /etc/apt-cacher-ng/backends_i2pd
</code></pre>

<p>and make apt-cacher-ng aware of it in /etc/apt-cacher-ng/acng.conf</p>

<pre><code>    Remap-i2pd: http://i2p.repo ; file:backends_i2pd
</code></pre>

<p><strong>Configuring apt to use your caching proxy</strong></p>

<p>Finally, you'll need to make your applications aware of apt-cacher-ng. To make
your host machine's apt aware of your proxy, you need to create a file
in /etc/apt/apt.conf.d/ that tells apt to look for it.</p>

<pre><code>    echo "Acquire::http { Proxy \"http://127.0.0.1:3142\"; };" | tee /etc/apt/apt.conf.d/02proxy
</code></pre>

<p>But to make live-build use it, add the proxy's address to your options in your
auto/config file.</p>

<pre><code>    lb config noauto --apt-http-proxy http://127.0.0.1:3142
</code></pre>
</div>
<div id="content">
<h1>Step Two: Auto Scripts</h1>

<p><a href="https://github.com/cmotc/hoarderMediaOS/blob/master/Tutorial/HOWTO.2.AUTOSCRIPTS.md">Standalone Chapter</a></p>

<h2>See also:</h2>

<ul>
<li><a href="https://debian-live.alioth.debian.org/live-manual/stable/manual/html/live-manual.en.html#334">Debian live systems manual, Dealing with Configuration Changes</a></li>
</ul>

<h2>Directory Configuration</h2>

<p>First, you'll need to create a new directory for your configuration and change
into it.</p>

<pre><code>    mkdir -p hoarder-live &amp;&amp; cd hoarder-live
</code></pre>

<h2>Auto Scripts</h2>

<p>The live-build uses a set of configuration files called "auto scripts" which are
held under a a directory called "auto" in the configuration directory. Create
this directory as well, and the following files within, clean, config, and
build.</p>

<pre><code>    mkdir -p auto &amp;&amp; cd auto
    touch clean config build
</code></pre>

<p>The clean, config, and build files are in-and-of-themselves just shell scripts,
which are called by the lb script when you invoke the relevant command. So
'lb config' runs the configuration file auto/config, lb build does auto/build,
lb clean does auto/clean.</p>

<h2>The noauto Option</h2>

<p>When you create an auto script, it runs the commands in the script <em>instead</em> of
the command. That means, in order to actually run the command with the auto
script, you have to run the command <em>in</em> the auto script, and if you run the
command in the auto script, it can't look for for the auto script again. So when
you write an auto script, you need to include the noauto option to make sure the
auto script works.</p>

<p><strong>Example auto/clean Figure 1:</strong></p>

<pre><code>    #! /usr/bin/env bash
    lb clean noauto \
        "$@"
</code></pre>

<p><strong>Example auto/config Figure 1:</strong></p>

<pre><code>    #! /usr/bin/env bash
    lb config noauto \
        "$@"
</code></pre>

<p><strong>Example auto/build Figure 1:</strong></p>

<pre><code>    #! /usr/bin/env bash
    lb build noauto \
        "$@"
</code></pre>

<p>Simple as that!. And now we're ready to start doing more interesting stuff.</p>

<h2>Setting Defaults</h2>

<p>The basic purpose of using an auto script is to set arguments which will be
passed to the lb command. Now if, for example, you wanted to make sure that lb
never keeps a cache of the files it downloads, you could add --purge to the
auto/clean script, like so:</p>

<p><strong>Example auto/clean Figure 2:</strong></p>

<pre><code>    #! /usr/bin/env bash
    lb clean noauto --purge
</code></pre>

<p>Most of the stuff auto scripts do, though, happens during the lb config command.
This command takes most of the options and sets up the configuration tree, so
it is the most detailed command. For example, to enable a live system and
installation from a live system, you should enable the options '-b iso-hybrid'
'--debian-installer live' and '--system live', or if you want to set the init
system you should use the '--initsystem' option. You can also set the options
of the programs that it live-build runs, like debootstrap, using
'--deboostrap-options'. For a complete list of options, you should see
'man lb_config'. An example of an auto script with alternate defaults to enable
installation from live media, sysv-based init, and a merged /usr/ would be:</p>

<p><strong>Example auto/config Figure 2:</strong></p>

<pre><code>    #! /usr/bin/env bash
    lb config noauto \
        -b iso-hybrid \
        --debian-installer live \
        --system live \
        --debootstrap-options "--merged-usr --variant=minbase --include=busybox-syslogd,gnupg2,gpgv-static,gnutls-bin" \
        --initsystem sysvinit \
        "$@"
</code></pre>

<p>setting additional options for lb build in auto/build isn't necessary.</p>

<h2>Pre-Process Scripting</h2>

<p>Besides setting options, since auto scripts are just shell scripts they can be
used to set things up in advance of the live-build steps. For example, the sid
version of live-build requires you to run 'sudo lb init $options' which will
create a directory called '.build'. In order to run this automatically, you
could add it to an auto script. Since it only needs to be run if it's artifacts
do not exist, I prefer to add it to the auto/clean script.</p>

<p><strong>Example auto/clean Figure 2:</strong></p>

<pre><code>    #! /usr/bin/env bash
    #If .build doesn't exist        #create it
    [ ! -d .build ] &amp;&amp;              sudo lb init -t 3 4
    lb clean noauto --purge
</code></pre>

<h2>Setting Options Conditionally</h2>

<p>Another thing you might be interested in doing, for example if you want to build
both a Free and Non-Free version of your iso, or both an Ubuntu and Debian based
version, or both only use a caching proxy when told to, you can set options in
auto scripts conditionally by representing them in environment variables. This
new example auto script conditionally applies settings that use contrib and
non-free, and conditionally sets a caching proxy by determining if a variable
in the outside environment has been set. For example, if $nonfree includes
anything, it will be adjudged "true" and $components will be set to contain the
value '--components=\"main,contrib,non-free\"'.</p>

<p><strong>Broken-down one-liner, pseudo-ternary if-else conditional:</strong></p>

<pre><code>    set components to
    components=     evaluate this command
                    $(      if $nonfree is set  then
                            [ ! -z "$nonfree" ] &amp;&amp;
                                    echo to stdout(set variable content)          else
                                    echo "--components=\"main,contrib,non-free\"" ||
                                            set content to blank
                                            echo "" )
</code></pre>

<p>So in our new auto/config command, we conditionally set options according to
the environment like this:</p>

<p><strong>Example auto/config Figure 2:</strong></p>

<pre><code>    #! /usr/bin/env bash
    components=$( [ ! -z "$nonfree" ] &amp;&amp; echo "--components=\"main,contrib,non-free\"" || echo "" )
    use_proxy=$( [ ! -z "$proxy" ] &amp;&amp; echo "--apt-http-proxy \"http://192.168.2.203\"" || echo "" )
    lb config noauto \
        "$use_proxy" \
        -b iso-hybrid \
        --debian-installer live \
        --system live \
        --debootstrap-options "--merged-usr --variant=minbase --include=busybox-syslogd,gnupg2,gpgv-static,gnutls-bin $components" \
        --initsystem sysvinit \
        "$@"
</code></pre>
</div>
<div id="content">
<h1>Step Three: Makefile</h1>

<p><a href="https://github.com/cmotc/hoarderMediaOS/blob/master/Tutorial/HOWTO.3.MAKEFILE.md">Standalone Chapter</a></p>

<p>Since the auto scripts are just shell scripts, it is absolutely possible to set
everything up within them and them alone. However, I think it's useful to add
a second layer of automation here, one that you can script in a little bit
different way, in order to help you automate the building of specific variants
of your liveCD. For example, I build a version of my liveCD which includes
non-free components for computers that need them, but only free components for
computers that don't. The non-free version installs a handful of additional
packages, and it would be a little bit more complicated to conditionally add
those packages in an auto script. Also, the use of a Makefile allows you to
create more generic auto scripts which can be used as the basis for a wider
variety of install media. Hopefully, this approach doesn't cause controversy.
After all, even though it's not strictly necessary with auto scripts, this is
pretty much the type of task that make is designed to automate.</p>

<h2>Supplementing your auto scripts with Make</h2>

<p>See Also: <a href="http://manpages.ubuntu.com/manpages/trusty/man1/lb_config.1.html">man lb_config</a></p>

<p>So you've got your auto/config script which provides the defaults for lb config.
But now, you're building variations on the theme and you want to give each
variation it's own tame without setting it in the auto script or having to type
it out every single time. Let's do this by supplementing our auto/config script
with part of our Makefile:</p>

<p><strong>Example Makefile Fragment: make config</strong></p>

<pre><code>    config:
            lb config --image-name tv
</code></pre>

<p>By following this example, we can automate the creation of more-or-less complex
variations of the lb config output. For example, to enable non-free packages,
set the '--archive-areas' option to '"main contrib nonfree"'.</p>

<pre><code>    config-nonfree:
            lb config --image-name tv-nonfree \
                    --archive-areas "main contrib nonfree"
</code></pre>

<p>or, to use a hardened kernel, set the '-k' option to the desired flavor,
'grsec-amd64'.</p>

<pre><code>    config-hardened:
            lb config --image-name tv-hardened \
                    -k grsec-amd64
</code></pre>

<p>Well that's considerable amount of typing saved, all told. And it's arguably a
bit easier to incorporate into something automatic. So let's keep this modular
automation via Make going and think of something else to automate.</p>

<h2>Installing Packages</h2>

<p>See Also: <a href="https://debian-live.alioth.debian.org/live-manual/stable/manual/html/live-manual.en.html#396">Customizing Package Installation</a></p>

<p>Telling the live-build system which packages is also just a matter of creating
a text file, in config/packages/*.list.{chroot, binary}. Just add packages per
their name in the repository, one line at a time. So to add the Awesome Window
Manager, the Uzbl web browser, the Surfraw terminal web helper, and youtube-dl,</p>

<p><strong>Example Makefile Fragment: make packages</strong></p>

<pre><code>    cd config/package-lists/ &amp;&amp; \
    echo "awesome" &gt;&gt; build.list.chroot &amp;&amp; \
    echo "awesome-extra" &gt;&gt; build.list.chroot &amp;&amp; \
    echo "surfraw" &gt;&gt; build.list.chroot &amp;&amp; \
    echo "surfraw-extra" &gt;&gt; build.list.chroot &amp;&amp; \
    echo "uzbl" &gt;&gt; build.list.chroot &amp;&amp; \
    echo "youtube-dl" &gt;&gt; build.list.chroot
</code></pre>

<p>After you've create build.list.chroot, link it to build.list.binary to make the
packages on the installed system as well as the live system.</p>

<pre><code>    ln -sf build.list.chroot build.list.binary
</code></pre>

<p>All together, 'make packages' should look a little like this:</p>

<pre><code>    packages:
            cd config/package-lists/ &amp;&amp; \
                    echo "awesome" &gt;&gt; build.list.chroot &amp;&amp; \
                    echo "awesome-extra" &gt;&gt; build.list.chroot &amp;&amp; \
                    echo "surfraw" &gt;&gt; build.list.chroot &amp;&amp; \
                    echo "surfraw-extra" &gt;&gt; build.list.chroot &amp;&amp; \
                    echo "uzbl" &gt;&gt; build.list.chroot &amp;&amp; \
                    echo "youtube-dl" &gt;&gt; build.list.chroot
                    ln -sf build.list.chroot build.list.binary
</code></pre>

<h2>Adding Third-Party Repositories to your system</h2>

<p>See Also: <a href="https://debian-live.alioth.debian.org/live-manual/stable/manual/html/live-manual.en.html#371">Package Sources</a></p>

<p>One of the most common tasks with live-build is adding a third-party repository
from which to retrieve software that isn't ready to be a part of Debian for one
reason or another. For example, the i2p networking protocol and it's c++ client,
i2pd which are available from <a href="https://i2pd.website">i2pd.website</a>. In order to
add a repository, you need to add it's sources.list entry and public key to the
config/archives/ directory.</p>

<p>So, the i2pd repository is at <a href="http://repo.lngserv.ru/debian">http://repo.lngserv.ru/debian</a>
and it distributes packages under the codename Jessie, corresponding to Debian
Jessie and distributing only main(free) packages. Let's use echo and tee to put
the i2pd.list.chroot file into place:</p>

<p><strong>Example Makefile Fragment: make i2pd-repo</strong></p>

<pre><code>    echo "deb http://repo.lngserv.ru/debian jessie main" | tee config/archives/i2pd.list.chroot
    echo "deb-src http://repo.lngserv.ru/debian jessie main" | tee -a config/archives/i2pd.list.chroot
</code></pre>

<p>I like to do it this way because it also puts the output on stdout, so I can
capture it if I have a problem. Next, we need to add the GPG key for i2pd. i2pd
has a GPG key fingerprint corresponding to 98EBCFE2, which we will retrieve
using GPG.</p>

<pre><code>    gpg --keyserver keys.gnupg.net --recv-keys 98EBCFE2
</code></pre>

<p>will put the key onto our keyring, but it's not in the live-build tree yet. To
do that, do</p>

<pre><code>    gpg -a --export 98EBCFE2 | tee config/archives/i2pd.list.key.chroot
</code></pre>

<p>This will ensure that i2pd's repository is present in the liveCD, but not the
installed system. To put it in both, create a symlink *.list.binary and
*.list.key.binary</p>

<pre><code>    cd config/archives/ \
            &amp;&amp; ln -sf i2pd.list.chroot i2pd.list.binary \
            &amp;&amp; ln -sf i2pd.list.key.chroot i2pd.list.key.binary
</code></pre>

<p>so, all together it looks like this:</p>

<pre><code>    i2pd-repo:
            echo "deb http://repo.lngserv.ru/debian jessie main" | tee config/archives/i2pd.list.chroot
            echo "deb-src http://repo.lngserv.ru/debian jessie main" | tee -a config/archives/i2pd.list.chroot
            gpg --keyserver keys.gnupg.net --recv-keys 98EBCFE2; \
            gpg -a --export 98EBCFE2 | tee config/archives/i2pd.list.key.chroot
            cd config/archives/ \
                    &amp;&amp; ln -sf i2pd.list.chroot i2pd.list.binary \
                    &amp;&amp; ln -sf i2pd.list.key.chroot i2pd.list.key.binary
</code></pre>

<p>On occasion, you might need to get a GPG key in some way other than via a GPG
keyserver. If it's over HTTPS, for instance, you can use 'curl -s' to the same
effect. For example, to include SyncThing's repository, create the sources.list
entry:</p>

<p><strong>Example Makefile Fragment: make syncthing-repo</strong></p>

<pre><code>    echo "deb http://apt.syncthing.net/ syncthing release" | tee config/archives/syncthing.list.chroot
</code></pre>

<p>and this time, replace 'gpg -a export $key' with 'curl -s $url'</p>

<pre><code>    curl -s https://syncthing.net/release-key.txt | tee config/archives/syncthing.list.key.chroot
</code></pre>

<p>and make your symlinks. All together, it should look like this:</p>

<pre><code>    syncthing-repo:
    echo "deb http://apt.syncthing.net/ syncthing release" | tee config/archives/syncthing.list.chroot
    curl -s https://syncthing.net/release-key.txt | tee config/archives/syncthing.list.key.chroot
    cd config/archives/ \
            &amp;&amp; ln -sf syncthing.list.chroot syncthing.list.binary \
            &amp;&amp; ln -sf syncthing.list.key.chroot syncthing.list.key.binary
</code></pre>

<p>Now, why do it this way? Well for one thing, that's pretty concise, but it's
also pretty obvious what it's doing. I think that's a pretty good idea. For
another thing, I might want to group these repositories categorially. Say I have
repositories for i2pd, tor, tox, PaleMoon, Plex, and Skype. Instead of typing
each out individually, I might put the first 4 in to "make libre" like so:</p>

<pre><code>    libre:
            make i2pd-repo; \
            make tor-repo; \
            make palemoon-repo; \
            make tox-repo; \
</code></pre>

<p>and the last two in to "make unfree" like so:</p>

<pre><code>    unfree:
            make playdeb-repo; \
            make plex-repo; \
</code></pre>

<h2>Editing the Default Home Directory Template</h2>

<p>See Also: <a href="https://debian-live.alioth.debian.org/live-manual/stable/manual/html/live-manual.en.html#500">Includes</a></p>

<p>Another basic customization that you may want to do is to alter the default home
directory template, a.k.a. etc/skel. Adding files and folders to etc/skel is
easy, you just add them in 'config/includes.chroot/etc/skel/' and
'config/includes.binary/etc/skel/'. Since you're basically going to be adding
files and folders to this folder, everything is literally exactly the same as
using the terminal to manage files and folders in any other context.</p>

<p>To create a folder, something like:</p>

<pre><code>    mkdir -p config/includes.chroot/etc/skel/Documents/Slideshows/
</code></pre>

<p>will do just fine.</p>

<p>Need to create a text file? How about a baseline .bash_aliases?</p>

<pre><code>    echo "#/usr/bin/env bash" | tee config/includes.binary/etc/skel/.bash_aliases
    echo "echo hello, $(whoami)" | tee config/includes.binary/etc/skel/.bash_aliases
</code></pre>

<p>Want to create a shell script and set it's permissions?</p>

<pre><code>    echo "#/usr/bin/env bash" | tee config/includes.binary/etc/skel/conky.sh; \
    echo "nohup bash -c 'sleep 2 &amp;&amp; conky 2&gt;1 /dev/null &amp;'" | tee config/includes.binary/etc/skel/conky.sh
    chmod +x config/includes.binary/etc/skel/conky.sh
</code></pre>

<p>I mean, even being that explicit is drawing it out. It's just that easy. So, all
together it should look like:</p>

<p><strong>Example Makefile Fragment: make skel</strong></p>

<pre><code>    skel:
            mkdir -p config/includes.chroot/etc/skel/Documents/Slideshows/
            echo "#/usr/bin/env bash" | tee config/includes.binary/etc/skel/.bash_aliases
            echo "echo hello, $(whoami)" | tee config/includes.binary/etc/skel/.bash_aliases
            echo "#/usr/bin/env bash" | tee config/includes.binary/etc/skel/conky.sh; \
            echo "nohup bash -c 'sleep 2 &amp;&amp; conky 2&gt;1 /dev/null &amp;'" | tee config/includes.binary/etc/skel/conky.sh
            chmod +x config/includes.binary/etc/skel/conky.sh
</code></pre>
</div>
<div id="content">
<h1>Step Four: Dockerfile</h1>

<p><a href="https://github.com/cmotc/hoarderMediaOS/blob/master/Tutorial/HOWTO.4.DOCKERFILE.md">Standalone Chapter</a></p>

<p>Now let's make it even easier, and, as a bonus, make our install media easy to
bootstrap from any distribution where Docker can readily be installed. Docker is
a container engine and it's just a hair shy of perfect for generating and
re-generating LiveCD's. Unfortunately, it's not possible to do the very last
step with a simple "docker build" so instead we'll do everything up to that
point. Also, live-build create a number of large build artifacts, that you
probably don't want to accidentally commit and then have the hassle of cleaning
out of your git history. Docker will build all this in a container leaving your
configuration directory neat and clean. Docker is also really easy to learn to
use for simple things, at least so let's look at it in chunks.</p>

<h2>Install Dependencies:</h2>

<p>Docker containers are a kind of virtual machine-ish thing, which is awesome
because we can pare it down to pretty much exactly the stuff we need to build
the liveCD on a highly consistent environment. Docker's got a pretty simple sort
of language to it's Dockerfiles, you inherit from an existing container with
FROM, you run commands in the container with RUN. So to create a Debian Sid
container and install live-build and our supplemental software in it, start your
Dockerfile like this:</p>

<p><strong>Example Dockerfile: install dependencies</strong></p>

<pre><code>    FROM debian:sid
    RUN apt-get update
    RUN apt-get install -yq \
            apt-transport-https \
            gpgv-static \
            gnupg2 \
            bash \
            apt-utils \
            live-build \
            debootstrap \
            make \
            curl
    RUN apt-get dist-upgrade -yq #I like to do this just to be sure. BTW, this is a comment in a Dockerfile
</code></pre>

<h2>Recreate Users and Working Directory</h2>

<p>Next, since live-build requires us to run commands as both a user and the root,
we need create a user to run commans as, a home directory, and a working
directory for our configuration. To create a user with an empty home directory
and a default bash shell, add the following line to the Dockerfile.</p>

<pre><code>    RUN useradd -ms /bin/bash livebuilder
</code></pre>

<p>Now, use the ADD Dockerfile command to create the working directory you will use
to create the iso.</p>

<pre><code>    ADD . /home/livebuilder/tv-live
</code></pre>

<p>Transfer ownership of the directory to the new user before doing anything else</p>

<pre><code>    RUN chown -R livebuilder:livebuilder /home/livebuilder/tv-live
</code></pre>

<p>Become the new user</p>

<pre><code>    USER livebuilder
</code></pre>

<p>And establish the working directory.</p>

<pre><code>    WORKDIR /home/livebuilder/tv-live
</code></pre>

<p>Now, all commands will be run as the user livebuilder in the directory
/home/livebuilder/tv-live</p>

<p><strong>Example Dockerfile: set up work area</strong></p>

<pre><code>    RUN useradd -ms /bin/bash livebuilder
    ADD . /home/livebuilder/tv-live
    RUN chown -R livebuilder:livebuilder /home/livebuilder/tv-live
    USER livebuilder
    WORKDIR /home/livebuilder/tv-live
</code></pre>

<h2>Copy the Configuration Files</h2>

<p>Now that our working area is ready, we need to copy our configuration files into
the new working directory. In dockerese, copying a folder and a file works the
same way. You just use the COPY command and specify what you wish to copy. So
to copy our auto folder in it's entirity, just do:</p>

<pre><code>    COPY auto /home/livebuilder/tv-live/auto
</code></pre>

<p>Now, for some reason I'm not entirely sure of, lb init doesn't work in the
Docker container. But it seems like all lb init does, at least the way I've been
using it, is create a folder called '.build' owned by root. So instead, I just
add another little helper to the Makefile to do just that at build time.</p>

<p><strong>Example Makefile Fragment: make docker-init</strong></p>

<pre><code>    docker-init:
            mkdir -p .build
</code></pre>

<p>and to copy the Makefile, just do:</p>

<pre><code>    COPY Makefile /home/livebuilder/tv-live/Makefile
</code></pre>

<p>and add the new init helper as root and switch back to the livebuilder user.</p>

<pre><code>    USER root
    RUN make docker-init
    USER livebuilder
</code></pre>

<p><strong>Example Dockerfile: copy build files</strong></p>

<pre><code>    COPY Makefile /home/livebuilder/tv-live/Makefile
    USER root
    RUN make docker-init
    USER livebuilder
</code></pre>

<h2>Run the Pre-Build Configuration</h2>

<p>Now, run your custom make commands to prepare the configuration folder and build
directory.</p>

<p><strong>Example Dockerfile: fine-tune configuration</strong></p>

<pre><code>    RUN make config-hardened
    RUN make syncthing-repo
    RUN make i2pd-repo
    RUN make skel
    RUN make packages
</code></pre>

<p>and you're almost done!</p>

<h2>Build the Container</h2>

<p>Now you run the commands in your Dockerfile by running docker build in the
current directory</p>

<pre><code>    docker build -t tv-build .
</code></pre>

<p>Just because I can, I keep this in the Makefile under 'make docker'</p>

<h2>Run the Priveleged Part of the Build and Extract the Artifacts</h2>

<p>Finally, in order to mount /proc in our container, we must run a command as a
priveleged user in the container. That command is lb build:</p>

<p>Edit: 11/16/2017: The container also requires access to a loopback device, as
   newly reflected below.</p>

<pre><code>    docker run -i --device /dev/loop0 --name "tv-build" --privileged -t tv-build lb build
</code></pre>

<p>Specifying the --name of the container you want to run the command in will keep
you from losing track of the build artifacts when you copy them to the host
machine later.</p>

<p><strong>Example auto/build Figure 2:</strong></p>

<pre><code>    #! /usr/bin/env bash
    lb build noauto \
        "$@"
    bash
</code></pre>

<p>From the prompt, you can inspect the results of the build, and extract the build
artifacts using docker cp:</p>

<pre><code>    docker cp tv-build:/home/livebuilder/tv-live/tv-* .
</code></pre>

<p>and you now have, what I think, is a pretty great way to remaster your own live
install media.</p>

<p>Unfortunately, because this depends on using chroots as they function in a
regular GNU/Linux distribution, this means that we won't be able to run our
build in Docker on our hardened-kernel system. We can work around this, however
imperfectly, by allowing mounts in chroots</p>

<pre><code>    sudo sysctl -w kernel.grsecurity.chroot_caps=0
    sudo sysctl -w kernel.grsecurity.chroot_deny_chmod=0
    sudo sysctl -w kernel.grsecurity.chroot_deny_mknod=0
    sudo sysctl -w kernel.grsecurity.chroot_deny_mount=0
    sudo sysctl -p
    docker run -i --device /dev/loop0 --privileged -t hoarder-build make build
    sudo sysctl -w kernel.grsecurity.chroot_caps=0
    sudo sysctl -w kernel.grsecurity.chroot_deny_chmod=1
    sudo sysctl -w kernel.grsecurity.chroot_deny_mknod=1
    sudo sysctl -w kernel.grsecurity.chroot_deny_mount=1
    sudo sysctl -p
</code></pre>
</div>
<div id="content">
<h1>Step Five: Provide a path to verify Authentic copies</h1>

<p><a href="https://github.com/cmotc/hoarderMediaOS/blob/master/Tutorial/HOWTO.5.AUTHENTICATE.md">Standalone Chapter</a></p>

<p>Like I said, we should all be careful about who we trust to assemble all our
software. Likewise, when you distribute it in binary form, it probably makes
sense to provide many ways to verify that the recipient of that copy has
obtained it authentically. To do this, you have many options, and you should
choose to use them all if possible.</p>

<h2>Compute Hashes</h2>

<p>The first step to helping your fellow enthusiast to verify the authenticity of
an image, you need to compute hashes of those images. A <em>hash function</em> takes
an arbitrary piece of data, any data will do, and creates a string of a fixed
size which is totally unique to the piece of data that was <em>hashed</em>. So when we
sha256sum our iso file, we will get a string that is unique to our iso file and
cannot be reproduced, without an exact copy of the original iso file. The tool
we should use for this is sha256sum, which computes hashes based on the Secure
Hashing Algorithm, the 256 bit version, which is used by many GNU/Linux
distributions to verify the authenticity of their distributed iso files.</p>

<p>In order to produce the sha256sum of the iso file, run the following command. It
make take a moment, especially if the file is large in size.</p>

<pre><code>    sha256sum tv-amd64.hybrid.iso
</code></pre>

<p>Once the hash is computed, it will be emitted to stdout in the form</p>

<pre><code>    86b70a74e30eec40bf129c44a8dd823c1320200825bc4222556ce1241d4863dd  tv-amd64.hybrid.iso
</code></pre>

<p>This can now be used to ensure that the file corresponds to the hash, which is
one half ot the authenticity puzzle. If you want to compute the hashes in your
Makefile, you could use something like the following snippet.</p>

<pre><code>    **Example Makefile Fragment: hash, delete empty on failure**
    hash:
            sha256sum tv-amd64.hybrid.iso &gt; \
                    tv-amd64.hybrid.iso.sha256sum || \
                    rm tv-amd64.hybrid.iso.sha256sum; \
</code></pre>

<p>Because piping the output of sha256sum will always produce a file, but if the
file to be hashed doesn't exist, the created file will be empty, we make sure
that sha256sum signals that it has completed <em>successfully</em> and if it fails, we
delete the created file.</p>

<h2>Sign Hashes</h2>

<p>Now we've got hashes to verify the iso's correspond to the hashes, but now we
need a way for the user to verify the provenance of the hashes themselves. In
order to do this, we need to sign them with a key that corresponds to some real
set of contact information. Traditionally, this has been an e-mail but maybe
something out there is better for you.</p>

<p>To get started, we need to generate a signing key. If you already have a signing
key you want to use, then you can skip this step.</p>

<p><a href="https://wiki.debian.org/Keysigning#Step_1:_Create_a_RSA_keypair">See Also: Key Generation/Distribution</a></p>

<p><a href="https://keyring.debian.org/creating-key.html">Also See Also: Key Generation</a></p>

<p>Before you do anything else, you should edit your $HOME/.gnupg/gpg.conf to not
use SHA1 as it's hashing algorithm.</p>

<pre><code>    personal-digest-preferences SHA256
    cert-digest-algo SHA256
    default-preference-list SHA512 SHA384 SHA256 SHA224 AES256 AES192 AES CAST5 ZLIB BZIP2 ZIP Uncompressed
</code></pre>

<p>Now, you'll need to start the gpg key generation procedure:</p>

<pre><code>    gpg --gen-key
</code></pre>

<p>You'll be prompted for whick key type you want to generate. RSA and RSA, the
default key type, is the one that we want. On the next prompt, you'll be
prompted to select a key size, and you should select 4096 for your signing key.
Then select a time frame for the key to be valid. For the sake of brevity, I
direct you to the second
<a href="https://keyring.debian.org/creating-key.html">link at the top of this section</a>.</p>

<p>Now that you're done with that, you've just got to get ready to share your key.
First, generate a key revocation certificate. Back it up someplace safe. You
will use it in case your private key is ever compromised to inform people that
they must disregard the compromised key and update to an uncompromised key.</p>

<pre><code>    gpg --gen-revoke ${KEY_ID} &gt; ~/.gnupg/revocation-${KEY_ID}.crt
</code></pre>

<p>Finally, share the <strong>public</strong> key with the world.</p>

<pre><code>    gpg --send-key ${KEY_ID}
</code></pre>

<p>Now that we've got our signing key, let's use it to sign the files:</p>

<pre><code>    gpg --batch --yes --clear-sign -u "$(SIGNING_KEY)" tv-amd64.hybrid.iso.sha256sum
</code></pre>

<p>After you're done, you'll have a signed copy of the hash file that looks like
this:</p>

<pre><code>    -----BEGIN PGP SIGNED MESSAGE-----
    Hash: SHA256

    86b70a74e30eec40bf129c44a8dd823c1320200825bc4222556ce1241d4863dd  tv-amd64.hybrid.iso
    -----BEGIN PGP SIGNATURE-----

    iQEzBAEBCAAdFiEEwM7uKXtf5F/2EKrG8F+F+kRsBCsFAllIqBoACgkQ8F+F+kRs
    BCubMwgAuf81nTIcmM8COY7T7RGp51ApiAMETU1tuHQbOKBKDRemgml2UZ0DNVLZ
    wCtnfErsQD8getUSpqSk07e448sCbEUYeifH8xS/6uC3JbCkITt4bDl6UdU2BXm0
    I9IkweK3d0hp5TIjs4m9fA3qVTto1v9EaUxQhREB3/do2FhqP+60ehqR3dgqLzOr
    5ueXxXCeFAHJhyvQk0EvKwvWciabqj8gY2ra5aEXE+kAJWz8mrLyK/4Q0IBwXMYm
    xPiXNctlaldqDCjsF42ronHQlHK7pg0l58Pht/kSh8ERKPyhtLGeOOrNyjcbg8/t
    HE65ErJ7ArZZJQ7KBdxFr8lzkrPsEg==
    =PrNx
    -----END PGP SIGNATURE-----
</code></pre>

<p>and can be used by anyone with your public key to assure that the hash they
are using, and thus the iso it corresponds to, came from the owner of the
corresponding private key and them alone. In order to make the signatures with
the Makefile, a fragment like the following will work. Note that we don't have
to delete failed signatures, a nonexistent file will just not produce a
signature.</p>

<pre><code>    **Example Makefile Fragment: sign the hash**
    sign:
            gpg --batch --yes --clear-sign -u "$(SIGNING_KEY)" \
                    tv-amd64.hybrid.iso.sha256sum ; \
</code></pre>
</div>
<div id="content">
<h1>Step Six: Create torrents and Release</h1>

<p><a href="https://github.com/cmotc/hoarderMediaOS/blob/master/Tutorial/HOWTO.6.RELEASE.md">Standalone Chapter</a></p>

<p>Now we've got everything we need to responsibly share our configuration except
a means of sharing it. Fortunately, with a little trickery you can actually
reliably bootstrap some really good ways of distributing your iso file. I like
a combination of Github Releases and a cool feature of the Bittorrent protocol
known as "Web Seeds" that allow you to supplement a Peer-to-Peer swarm with an
HTTP or HTTPS source. Unfortunately, in order to make this automatic we have to
install an additional couple of dependencies. Fortunately for us, one of those
dependencies is in Go! Go is an awesome language that anyone can use.
Unfortunately for us, it's because the excellent Go software involved here isn't
quite available in Debian just yet.</p>

<h2>Install Extra Dependencies</h2>

<p>OK so first, we need to install the extra dependencies here. We'll be using the
terminal tool "mktorrent" to generate our torrent files, and we'll be using
golang to get the github-release package.</p>

<pre><code>    sudo apt-get install mktorrent golang
</code></pre>

<p>Now, set the GOPATH and run 'go get' to retrieve the package</p>

<pre><code>    export GOPATH="$HOME/.go"
    mkdir -p "$GOPATH"
    go get github.com/aktau/github-release
</code></pre>

<p>And include the GOPATH in your PATH</p>

<pre><code>    export PATH="$GOPATH:$PATH"
</code></pre>

<p>Now, generate a torrent from the file. I just added a bunch of public annouce
URLS to it, these are open trackers anyone can use. Note that we also use a
Web Seed to supplement our torrent. This is very, very important, it'll provide
a consistent source for downloads until a large enough swarm exists that it is
no longer neccessary.</p>

<pre><code>    mktorrent -a "udp://tracker.openbittorrent.com:80" \
    -a "udp://tracker.publicbt.com:80" \
    -a "udp://tracker.istole.it:80" \
    -a "udp://tracker.btzoo.eu:80/announce" \
    -a "http://opensharing.org:2710/announce" \
    -a "udp://open.demonii.com:1337/announce" \
    -a "http://announce.torrentsmd.com:8080/announce.php" \
    -a "http://announce.torrentsmd.com:6969/announce" \
    -a "http://bt.careland.com.cn:6969/announce" \
    -a "http://i.bandito.org/announce" \
    -a "http://bttrack.9you.com/announce" \
    -w https://github.com/"$(MY_ACCOUNT)"/"$(MY_ISO)"/releases/download/$(shell date +'%y.%m.%d')/tv.iso \
    tv-amd64.hybrid.iso; \
</code></pre>

<p>Awesome, now that the torrent is generated, generate a tag for the release on
github. I just use the date to tag the releases, as the point of this procedure
is to run builds frequently.</p>

<pre><code>    git tag $(date +'%y.%m.%d'); git push --tags github
</code></pre>

<p>in a Makefile, the same command will need to look like this:</p>

<pre><code>    git tag $(shell date +'%y.%m.%d'); git push --tags github
</code></pre>

<p>In order to create a Github release for that tag, you'll need to use the
program we downloaded with go get, github-release:</p>

<pre><code>    github-release release \
    --user "$(MY_ACCOUNT)" \
    --repo "$(MY_ISO)" \
    --tag $(shell date +'%y.%m.%d') \
    --name "$(MY_ISO)" \
    --description "A re-buildable OS for self-hosting. Please use the torrent if possible" \
    --pre-release ; \
</code></pre>

<p>Now we're ready to upload our built images and verification materials to the
release page. I generally upload them from smallest to largest files so to
upload the sha256 hash:</p>

<pre><code>    github-release upload --user "$(MY_ACCOUNT)" --repo "$(MY_ISO)" --tag $(shell date +'%y.%m.%d') \
            --name "$(MY_ISO)" \
            --file tv-amd64.hybrid.iso.sha256sum; \
</code></pre>

<p>And the signed sha256 hash:</p>

<pre><code>    github-release upload --user "$(MY_ACCOUNT)" --repo "$(MY_ISO)" --tag $(shell date +'%y.%m.%d') \
            --name "$(MY_ISO)" \
            --file tv-amd64.hybrid.iso.sha256sum.asc;\
</code></pre>

<p>And the torrent file:</p>

<pre><code>    github-release upload --user "$(MY_ACCOUNT)" --repo "$(MY_ISO)" --tag $(shell date +'%y.%m.%d') \
            --name "$(MY_ISO)" \
            --file tv-amd64.hybrid.iso.torrent;\
</code></pre>

<p>and finally, the bootable, Live ISO image.</p>

<pre><code>    github-release upload --user "$(MY_ACCOUNT)" --repo "$(MY_ISO)" --tag $(shell date +'%y.%m.%d') \
            --name "$(MY_ISO)" \
            --file tv-amd64.hybrid.iso;\
</code></pre>
</div>
<div id="content">
<h1>How I decided to continuously remaster my own Debian Variant without, like, totally meaning to.</h1>

<p><a href="https://github.com/cmotc/hoarderMediaOS/blob/master/Tutorial/HOWTO.0.INTRODUCTION.md">Standalone Chapter</a></p>

<p>OK, this thing is a work in progress, so bear with me while I do it, but here's
what I'm attempting. I have spent alot of time refining my home PC's
configuration based on defaults in the Debian installer, and the packages
themselves, and I've been pretty successful at it. But it's an ongoing process,
and sometimes, you bork something and you've got to reinstall. Which means that
you've got to reproduce all that configuration and start over, which kind of
sucks. There are many ways to approach this, and what this readme is going to
amount to is simply an example of but one way of doing things(With some
variations, because some of the things that Docker can allow you to do are
awesome). I wanted a lightweight media-center OS for retro gaming that could
double as a Media Server, I totally uncreatively called it hoarderMediaOS, and
now it's a reasonably easy to reproduce procedure and I hope it's helpful. It's
based on Unstable, though, so it's might become outdated at any moment. I'm
going to keep doing it though, so I'll probably notice if it stops working.</p>

<h2>Who this tutorial is targeted at</h2>

<p>Enthusiastic Amateurs! People who like Debian/Ubuntu based distributions for
their excellent stability and diligent community, but who don't necessarily
want to use one of the regular desktop environments in the default
configuration. Ricers, datahoarders, and hobbyists who would rather use Debian
than Arch or Gentoo. Anyone who uses their home computer for experimentation.
The point of this tutorial is that <strong>anyone</strong> can learn to continuously
customize their Linux configuration if they wish to, <strong>anyone</strong>, even a solitary
hobbyist with no significant organizational resources.</p>

<p><strong>Is it a distro?</strong></p>

<p><strong>God I hope not.</strong> I'm not a person who really likes to deal in opinion. I
deleted my whole blog because I felt obligated to be personal. Unfortunately,
I have an opinion. I'm opinionated. And it's my opinion that it's too easy for
people to consider any installable media that gets redistributed equal to a
recognizable distro. It's just not. Tiny distros can be <strong>amazing</strong>, I loved
CrunchBang and felt genuine sadness when corenominal gave it up, and genuine
excitement for BunsenLabs and Crunchbang++. I love Linux Mint and think
Cinnamon will ease many people's Dad's transition into using GNU/Linux from
Windows when they start to get pissed off about Windows 10 serving them ads
all the damn time. But there are caveats to using these tiny niche distros. You
have to take matters into your own hands at times, even things that are second
nature to you or me, might not be obvious to a first-time Mint user, even things
as simple as being able to use AskUbuntu to get help. It takes a while to learn
to translate the Arch wiki.</p>

<p>Depending on their complexity, they may also configure 3rd-party repositorys.
<strong>Please consider that in the most serious of terms</strong>. If they configured a
third-party repository, they have probably used it to install something. That
application was installed from that third-party repository because it's probably
experimental and <strong>not ready to be held to the standards of an official Debian</strong>
<strong>package</strong>. That doesn't mean it's bad. Lots of software from third-party
repositories is <strong>awesome</strong> but using third party software is kind of a big
decision.</p>

<p>It is my opinion that there ought to be a clearer way to consider these two
types of distros specifically. Maybe something like "Upstream Distro" and
"Enthusiast Distro" as a place to instigate a lexical split, and make clear the
advantages, disadvantages, and implications of each. Using an "Enthusiast
Distro" is fun, and creating one is fun. Sharing them ought to be fun, too.
I would be more comfortable sharing my own "Enthusiast Distro" if I were sure
people understood, I'm just one guy, depending on the work of thousands, I think
building riced install media is fun, and that's <strong>it</strong>.</p>

<h2>What am I actually going to talk about?</h2>

<p>live-build, docker, sid, make. Specifically, I'm going to teach you how to use
these tools to continuously package your own personal configuration of Debian
as an iso that can be used to create install media, just like the regular Debian
LiveCD's.</p>

<h2>What are you going to need?</h2>

<p>Either Debian unstable(sid), Devuan unstable(ceres) or any distribution
supporting Docker and coming configured with the Docker Hub.</p>

<p><strong>On that note, Dependencies</strong></p>

<pre><code>    Debian Sid/Devuan Ceres
    =======================
    sudo apt-get install live-build debootstrap make
    optionally,
    sudo apt-get install git docker.io
</code></pre>

<p>or install docker per your distribution's instructions or from source. Docker
will use the debian:sid container as a base. A git repository or a git hosting
service will also be helpful if you want to backup and share your configuration.</p>

<h1>Step Zero: A crash course in live-build</h1>

<p><a href="https://github.com/cmotc/hoarderMediaOS/blob/master/Tutorial/HOWTO.1.LIVEBUILD.md">Standalone Chapter</a></p>

<h2>See also:</h2>

<ul>
<li><a href="https://debian-live.alioth.debian.org/live-manual/stable/manual/html/live-manual.en.html#178">Debian live systems manual, First Steps</a></li>
</ul>

<p>All in all, live-build is a pretty simple, straightforward, regular tool to use.
For most purposes, it will come down to the use of three commands. These
commands are:</p>

<ol>
<li>lb config</li>
<li>lb build</li>
<li>lb clean</li>
</ol>

<p>If you wanted to create the absolute bare-minimum default liveCD that live-build
will generate, you could simply run</p>

<pre><code>    lb config &amp;&amp; sudo lb build
</code></pre>

<p>in an empty directory and in a few minutes, you'd have a basic liveCD. However,
it wouldn't be very useful. This CD won't have an X server, or many of the
applications desktop Linux users may have come to take for granted. Fortunately,
it's pretty easy to turn this into a base system. Just add a desktop metapackage
to the configuration, in between the two commands.</p>

<pre><code>    lb config
    echo 'budgie-desktop' &gt;&gt; config/packages/live.list.chroot
    sudo lb build
</code></pre>

<p>This will get you a live system with the excellent budgie desktop. In doing so,
it will many packages on the liveCD that budgie-desktop depends on.</p>

<h1>Step One: Set up your own caching proxy for apt(You'll be much better off)</h1>

<p><a href="https://github.com/cmotc/hoarderMediaOS/blob/master/Tutorial/HOWTO.2.APTCACHERNG.md">Standalone Chapter</a></p>

<h2>See-also:</h2>

<ul>
<li><a href="https://www.unix-ag.uni-kl.de/~bloch/acng/">apt-cacher-ng Homepage and Configuration Instructions</a></li>
<li><a href="https://docs.docker.com/engine/examples/apt-cacher-ng/">apt-cacher-ng dockerized</a></li>
</ul>

<p>After running debootstrap fourty or fifty times, you might be thinking "This
wasn't so bad the first time, but this is definitely not an instantaneous thing.
Sure would be nice to mirror these somewhere immediately nearby." And you might
try and search for how to set up a mirror and get discouraged by how large it
is. That's what apt-cacher-ng is for. apt-cacher-ng is a caching proxy that
is used to cache packages downloaded by package managers in your Linux
distributions. It will only cache the packages you request from it, so it's only
as big as it needs to be, and it can be used to bootstrap your live disk and
your installation, which will save you much bandwidth. And it's super easy to
configure, too. If you're using only the main Debian repositories especially,
it should just work, right out of the box, and if all your third-party
repositories are using plain http, they can be used through apt-cacher-ng
transparently, although it will not cache those packages unless it is configured
to. It seems like there are three main situations where you might want to make a
change to how apt-cacher-ng works by default.</p>

<p><strong>Allow https repositories to CONNECT through apt-cacher-ng</strong></p>

<p>Increasingly, some software sources are making their repositories available only
by way of https. This is probably not like, super necessary, as it will do
little to obscure the nature of the traffic, but I think it's nice in general.
But it presents a problem if you use apt-cacher-ng. It will not connect to https
repositories by default. In order to allow it to, you can simply uncomment this
line:</p>

<pre><code>    # PassThroughPattern: .* # this would allow CONNECT to everything
</code></pre>

<p>so it looks like this.</p>

<pre><code>    PassThroughPattern: .* # this would allow CONNECT to everything
</code></pre>

<p>and voila! You can now use https repositories through your apt-cacher-ng
instance, however it will not cache those packages yet.</p>

<p><strong>Third-party Repository using plain http</strong></p>

<p>If you want to cache packages from a thrid-party repository using apt-cacher-ng,
such as the Devuan repository, then you will need to create a backend for that
package and then make apt-cacher-ng aware of that backend. A backend is simply
a file containing the url of the repository you want to use. So to create a
backend for Devuan or any other repository available over plain http, one need
only:</p>

<pre><code>    echo "http://packages.devuan.org/merged" | sudo tee /etc/apt-cacher-ng/backends_devuan
</code></pre>

<p>Then, in order to make apt-cacher-ng aware of it's existence, you need to
configure is in /etc/apt-cacher-ng/acng.conf. In this configuration line, you'll
remap the Devuan mirror to a new name and tell it to use the backends_devuan
file.</p>

<pre><code>    Remap-devrep: file:devuan_mirror /merged ; file:backends_devuan # Devuan Archives
</code></pre>

<p>Next time you start your apt-cacher-ng instance, it will know to cache Devuan
packages.</p>

<p><strong>Third-party Repository caching using https</strong></p>

<p>It would also be nice to cache https repositories, and you can do just that with
apt-cacher-ng. It's pretty similar to using it with plain http, a backend is
still just as mu</p>

<pre><code>    echo "https://repo.lngserv.ru/debian" | tee /etc/apt-cacher-ng/backends_i2pd
</code></pre>

<p>and make apt-cacher-ng aware of it in /etc/apt-cacher-ng/acng.conf</p>

<pre><code>    Remap-i2pd: http://i2p.repo ; file:backends_i2pd
</code></pre>

<p><strong>Configuring apt to use your caching proxy</strong></p>

<p>Finally, you'll need to make your applications aware of apt-cacher-ng. To make
your host machine's apt aware of your proxy, you need to create a file
in /etc/apt/apt.conf.d/ that tells apt to look for it.</p>

<pre><code>    echo "Acquire::http { Proxy \"http://127.0.0.1:3142\"; };" | tee /etc/apt/apt.conf.d/02proxy
</code></pre>

<p>But to make live-build use it, add the proxy's address to your options in your
auto/config file.</p>

<pre><code>    lb config noauto --apt-http-proxy http://127.0.0.1:3142
</code></pre>

<h1>Step Two: Auto Scripts</h1>

<p><a href="https://github.com/cmotc/hoarderMediaOS/blob/master/Tutorial/HOWTO.2.AUTOSCRIPTS.md">Standalone Chapter</a></p>

<h2>See also:</h2>

<ul>
<li><a href="https://debian-live.alioth.debian.org/live-manual/stable/manual/html/live-manual.en.html#334">Debian live systems manual, Dealing with Configuration Changes</a></li>
</ul>

<h2>Directory Configuration</h2>

<p>First, you'll need to create a new directory for your configuration and change
into it.</p>

<pre><code>    mkdir -p hoarder-live &amp;&amp; cd hoarder-live
</code></pre>

<h2>Auto Scripts</h2>

<p>The live-build uses a set of configuration files called "auto scripts" which are
held under a a directory called "auto" in the configuration directory. Create
this directory as well, and the following files within, clean, config, and
build.</p>

<pre><code>    mkdir -p auto &amp;&amp; cd auto
    touch clean config build
</code></pre>

<p>The clean, config, and build files are in-and-of-themselves just shell scripts,
which are called by the lb script when you invoke the relevant command. So
'lb config' runs the configuration file auto/config, lb build does auto/build,
lb clean does auto/clean.</p>

<h2>The noauto Option</h2>

<p>When you create an auto script, it runs the commands in the script <em>instead</em> of
the command. That means, in order to actually run the command with the auto
script, you have to run the command <em>in</em> the auto script, and if you run the
command in the auto script, it can't look for for the auto script again. So when
you write an auto script, you need to include the noauto option to make sure the
auto script works.</p>

<p><strong>Example auto/clean Figure 1:</strong></p>

<pre><code>    #! /usr/bin/env bash
    lb clean noauto \
        "$@"
</code></pre>

<p><strong>Example auto/config Figure 1:</strong></p>

<pre><code>    #! /usr/bin/env bash
    lb config noauto \
        "$@"
</code></pre>

<p><strong>Example auto/build Figure 1:</strong></p>

<pre><code>    #! /usr/bin/env bash
    lb build noauto \
        "$@"
</code></pre>

<p>Simple as that!. And now we're ready to start doing more interesting stuff.</p>

<h2>Setting Defaults</h2>

<p>The basic purpose of using an auto script is to set arguments which will be
passed to the lb command. Now if, for example, you wanted to make sure that lb
never keeps a cache of the files it downloads, you could add --purge to the
auto/clean script, like so:</p>

<p><strong>Example auto/clean Figure 2:</strong></p>

<pre><code>    #! /usr/bin/env bash
    lb clean noauto --purge
</code></pre>

<p>Most of the stuff auto scripts do, though, happens during the lb config command.
This command takes most of the options and sets up the configuration tree, so
it is the most detailed command. For example, to enable a live system and
installation from a live system, you should enable the options '-b iso-hybrid'
'--debian-installer live' and '--system live', or if you want to set the init
system you should use the '--initsystem' option. You can also set the options
of the programs that it live-build runs, like debootstrap, using
'--deboostrap-options'. For a complete list of options, you should see
'man lb_config'. An example of an auto script with alternate defaults to enable
installation from live media, sysv-based init, and a merged /usr/ would be:</p>

<p><strong>Example auto/config Figure 2:</strong></p>

<pre><code>    #! /usr/bin/env bash
    lb config noauto \
        -b iso-hybrid \
        --debian-installer live \
        --system live \
        --debootstrap-options "--merged-usr --variant=minbase --include=busybox-syslogd,gnupg2,gpgv-static,gnutls-bin" \
        --initsystem sysvinit \
        "$@"
</code></pre>

<p>setting additional options for lb build in auto/build isn't necessary.</p>

<h2>Pre-Process Scripting</h2>

<p>Besides setting options, since auto scripts are just shell scripts they can be
used to set things up in advance of the live-build steps. For example, the sid
version of live-build requires you to run 'sudo lb init $options' which will
create a directory called '.build'. In order to run this automatically, you
could add it to an auto script. Since it only needs to be run if it's artifacts
do not exist, I prefer to add it to the auto/clean script.</p>

<p><strong>Example auto/clean Figure 2:</strong></p>

<pre><code>    #! /usr/bin/env bash
    #If .build doesn't exist        #create it
    [ ! -d .build ] &amp;&amp;              sudo lb init -t 3 4
    lb clean noauto --purge
</code></pre>

<h2>Setting Options Conditionally</h2>

<p>Another thing you might be interested in doing, for example if you want to build
both a Free and Non-Free version of your iso, or both an Ubuntu and Debian based
version, or both only use a caching proxy when told to, you can set options in
auto scripts conditionally by representing them in environment variables. This
new example auto script conditionally applies settings that use contrib and
non-free, and conditionally sets a caching proxy by determining if a variable
in the outside environment has been set. For example, if $nonfree includes
anything, it will be adjudged "true" and $components will be set to contain the
value '--components=\"main,contrib,non-free\"'.</p>

<p><strong>Broken-down one-liner, pseudo-ternary if-else conditional:</strong></p>

<pre><code>    set components to
    components=     evaluate this command
                    $(      if $nonfree is set  then
                            [ ! -z "$nonfree" ] &amp;&amp;
                                    echo to stdout(set variable content)          else
                                    echo "--components=\"main,contrib,non-free\"" ||
                                            set content to blank
                                            echo "" )
</code></pre>

<p>So in our new auto/config command, we conditionally set options according to
the environment like this:</p>

<p><strong>Example auto/config Figure 2:</strong></p>

<pre><code>    #! /usr/bin/env bash
    components=$( [ ! -z "$nonfree" ] &amp;&amp; echo "--components=\"main,contrib,non-free\"" || echo "" )
    use_proxy=$( [ ! -z "$proxy" ] &amp;&amp; echo "--apt-http-proxy \"http://192.168.2.203\"" || echo "" )
    lb config noauto \
        "$use_proxy" \
        -b iso-hybrid \
        --debian-installer live \
        --system live \
        --debootstrap-options "--merged-usr --variant=minbase --include=busybox-syslogd,gnupg2,gpgv-static,gnutls-bin $components" \
        --initsystem sysvinit \
        "$@"
</code></pre>

<h1>Step Three: Makefile</h1>

<p><a href="https://github.com/cmotc/hoarderMediaOS/blob/master/Tutorial/HOWTO.3.MAKEFILE.md">Standalone Chapter</a></p>

<p>Since the auto scripts are just shell scripts, it is absolutely possible to set
everything up within them and them alone. However, I think it's useful to add
a second layer of automation here, one that you can script in a little bit
different way, in order to help you automate the building of specific variants
of your liveCD. For example, I build a version of my liveCD which includes
non-free components for computers that need them, but only free components for
computers that don't. The non-free version installs a handful of additional
packages, and it would be a little bit more complicated to conditionally add
those packages in an auto script. Also, the use of a Makefile allows you to
create more generic auto scripts which can be used as the basis for a wider
variety of install media. Hopefully, this approach doesn't cause controversy.
After all, even though it's not strictly necessary with auto scripts, this is
pretty much the type of task that make is designed to automate.</p>

<h2>Supplementing your auto scripts with Make</h2>

<p>See Also: <a href="http://manpages.ubuntu.com/manpages/trusty/man1/lb_config.1.html">man lb_config</a></p>

<p>So you've got your auto/config script which provides the defaults for lb config.
But now, you're building variations on the theme and you want to give each
variation it's own tame without setting it in the auto script or having to type
it out every single time. Let's do this by supplementing our auto/config script
with part of our Makefile:</p>

<p><strong>Example Makefile Fragment: make config</strong></p>

<pre><code>    config:
            lb config --image-name tv
</code></pre>

<p>By following this example, we can automate the creation of more-or-less complex
variations of the lb config output. For example, to enable non-free packages,
set the '--archive-areas' option to '"main contrib nonfree"'.</p>

<pre><code>    config-nonfree:
            lb config --image-name tv-nonfree \
                    --archive-areas "main contrib nonfree"
</code></pre>

<p>or, to use a hardened kernel, set the '-k' option to the desired flavor,
'grsec-amd64'.</p>

<pre><code>    config-hardened:
            lb config --image-name tv-hardened \
                    -k grsec-amd64
</code></pre>

<p>Well that's considerable amount of typing saved, all told. And it's arguably a
bit easier to incorporate into something automatic. So let's keep this modular
automation via Make going and think of something else to automate.</p>

<h2>Installing Packages</h2>

<p>See Also: <a href="https://debian-live.alioth.debian.org/live-manual/stable/manual/html/live-manual.en.html#396">Customizing Package Installation</a></p>

<p>Telling the live-build system which packages is also just a matter of creating
a text file, in config/packages/*.list.{chroot, binary}. Just add packages per
their name in the repository, one line at a time. So to add the Awesome Window
Manager, the Uzbl web browser, the Surfraw terminal web helper, and youtube-dl,</p>

<p><strong>Example Makefile Fragment: make packages</strong></p>

<pre><code>    cd config/package-lists/ &amp;&amp; \
    echo "awesome" &gt;&gt; build.list.chroot &amp;&amp; \
    echo "awesome-extra" &gt;&gt; build.list.chroot &amp;&amp; \
    echo "surfraw" &gt;&gt; build.list.chroot &amp;&amp; \
    echo "surfraw-extra" &gt;&gt; build.list.chroot &amp;&amp; \
    echo "uzbl" &gt;&gt; build.list.chroot &amp;&amp; \
    echo "youtube-dl" &gt;&gt; build.list.chroot
</code></pre>

<p>After you've create build.list.chroot, link it to build.list.binary to make the
packages on the installed system as well as the live system.</p>

<pre><code>    ln -sf build.list.chroot build.list.binary
</code></pre>

<p>All together, 'make packages' should look a little like this:</p>

<pre><code>    packages:
            cd config/package-lists/ &amp;&amp; \
                    echo "awesome" &gt;&gt; build.list.chroot &amp;&amp; \
                    echo "awesome-extra" &gt;&gt; build.list.chroot &amp;&amp; \
                    echo "surfraw" &gt;&gt; build.list.chroot &amp;&amp; \
                    echo "surfraw-extra" &gt;&gt; build.list.chroot &amp;&amp; \
                    echo "uzbl" &gt;&gt; build.list.chroot &amp;&amp; \
                    echo "youtube-dl" &gt;&gt; build.list.chroot
                    ln -sf build.list.chroot build.list.binary
</code></pre>

<h2>Adding Third-Party Repositories to your system</h2>

<p>See Also: <a href="https://debian-live.alioth.debian.org/live-manual/stable/manual/html/live-manual.en.html#371">Package Sources</a></p>

<p>One of the most common tasks with live-build is adding a third-party repository
from which to retrieve software that isn't ready to be a part of Debian for one
reason or another. For example, the i2p networking protocol and it's c++ client,
i2pd which are available from <a href="https://i2pd.website">i2pd.website</a>. In order to
add a repository, you need to add it's sources.list entry and public key to the
config/archives/ directory.</p>

<p>So, the i2pd repository is at <a href="http://repo.lngserv.ru/debian">http://repo.lngserv.ru/debian</a>
and it distributes packages under the codename Jessie, corresponding to Debian
Jessie and distributing only main(free) packages. Let's use echo and tee to put
the i2pd.list.chroot file into place:</p>

<p><strong>Example Makefile Fragment: make i2pd-repo</strong></p>

<pre><code>    echo "deb http://repo.lngserv.ru/debian jessie main" | tee config/archives/i2pd.list.chroot
    echo "deb-src http://repo.lngserv.ru/debian jessie main" | tee -a config/archives/i2pd.list.chroot
</code></pre>

<p>I like to do it this way because it also puts the output on stdout, so I can
capture it if I have a problem. Next, we need to add the GPG key for i2pd. i2pd
has a GPG key fingerprint corresponding to 98EBCFE2, which we will retrieve
using GPG.</p>

<pre><code>    gpg --keyserver keys.gnupg.net --recv-keys 98EBCFE2
</code></pre>

<p>will put the key onto our keyring, but it's not in the live-build tree yet. To
do that, do</p>

<pre><code>    gpg -a --export 98EBCFE2 | tee config/archives/i2pd.list.key.chroot
</code></pre>

<p>This will ensure that i2pd's repository is present in the liveCD, but not the
installed system. To put it in both, create a symlink *.list.binary and
*.list.key.binary</p>

<pre><code>    cd config/archives/ \
            &amp;&amp; ln -sf i2pd.list.chroot i2pd.list.binary \
            &amp;&amp; ln -sf i2pd.list.key.chroot i2pd.list.key.binary
</code></pre>

<p>so, all together it looks like this:</p>

<pre><code>    i2pd-repo:
            echo "deb http://repo.lngserv.ru/debian jessie main" | tee config/archives/i2pd.list.chroot
            echo "deb-src http://repo.lngserv.ru/debian jessie main" | tee -a config/archives/i2pd.list.chroot
            gpg --keyserver keys.gnupg.net --recv-keys 98EBCFE2; \
            gpg -a --export 98EBCFE2 | tee config/archives/i2pd.list.key.chroot
            cd config/archives/ \
                    &amp;&amp; ln -sf i2pd.list.chroot i2pd.list.binary \
                    &amp;&amp; ln -sf i2pd.list.key.chroot i2pd.list.key.binary
</code></pre>

<p>On occasion, you might need to get a GPG key in some way other than via a GPG
keyserver. If it's over HTTPS, for instance, you can use 'curl -s' to the same
effect. For example, to include SyncThing's repository, create the sources.list
entry:</p>

<p><strong>Example Makefile Fragment: make syncthing-repo</strong></p>

<pre><code>    echo "deb http://apt.syncthing.net/ syncthing release" | tee config/archives/syncthing.list.chroot
</code></pre>

<p>and this time, replace 'gpg -a export $key' with 'curl -s $url'</p>

<pre><code>    curl -s https://syncthing.net/release-key.txt | tee config/archives/syncthing.list.key.chroot
</code></pre>

<p>and make your symlinks. All together, it should look like this:</p>

<pre><code>    syncthing-repo:
    echo "deb http://apt.syncthing.net/ syncthing release" | tee config/archives/syncthing.list.chroot
    curl -s https://syncthing.net/release-key.txt | tee config/archives/syncthing.list.key.chroot
    cd config/archives/ \
            &amp;&amp; ln -sf syncthing.list.chroot syncthing.list.binary \
            &amp;&amp; ln -sf syncthing.list.key.chroot syncthing.list.key.binary
</code></pre>

<p>Now, why do it this way? Well for one thing, that's pretty concise, but it's
also pretty obvious what it's doing. I think that's a pretty good idea. For
another thing, I might want to group these repositories categorially. Say I have
repositories for i2pd, tor, tox, PaleMoon, Plex, and Skype. Instead of typing
each out individually, I might put the first 4 in to "make libre" like so:</p>

<pre><code>    libre:
            make i2pd-repo; \
            make tor-repo; \
            make palemoon-repo; \
            make tox-repo; \
</code></pre>

<p>and the last two in to "make unfree" like so:</p>

<pre><code>    unfree:
            make playdeb-repo; \
            make plex-repo; \
</code></pre>

<h2>Editing the Default Home Directory Template</h2>

<p>See Also: <a href="https://debian-live.alioth.debian.org/live-manual/stable/manual/html/live-manual.en.html#500">Includes</a></p>

<p>Another basic customization that you may want to do is to alter the default home
directory template, a.k.a. etc/skel. Adding files and folders to etc/skel is
easy, you just add them in 'config/includes.chroot/etc/skel/' and
'config/includes.binary/etc/skel/'. Since you're basically going to be adding
files and folders to this folder, everything is literally exactly the same as
using the terminal to manage files and folders in any other context.</p>

<p>To create a folder, something like:</p>

<pre><code>    mkdir -p config/includes.chroot/etc/skel/Documents/Slideshows/
</code></pre>

<p>will do just fine.</p>

<p>Need to create a text file? How about a baseline .bash_aliases?</p>

<pre><code>    echo "#/usr/bin/env bash" | tee config/includes.binary/etc/skel/.bash_aliases
    echo "echo hello, $(whoami)" | tee config/includes.binary/etc/skel/.bash_aliases
</code></pre>

<p>Want to create a shell script and set it's permissions?</p>

<pre><code>    echo "#/usr/bin/env bash" | tee config/includes.binary/etc/skel/conky.sh; \
    echo "nohup bash -c 'sleep 2 &amp;&amp; conky 2&gt;1 /dev/null &amp;'" | tee config/includes.binary/etc/skel/conky.sh
    chmod +x config/includes.binary/etc/skel/conky.sh
</code></pre>

<p>I mean, even being that explicit is drawing it out. It's just that easy. So, all
together it should look like:</p>

<p><strong>Example Makefile Fragment: make skel</strong></p>

<pre><code>    skel:
            mkdir -p config/includes.chroot/etc/skel/Documents/Slideshows/
            echo "#/usr/bin/env bash" | tee config/includes.binary/etc/skel/.bash_aliases
            echo "echo hello, $(whoami)" | tee config/includes.binary/etc/skel/.bash_aliases
            echo "#/usr/bin/env bash" | tee config/includes.binary/etc/skel/conky.sh; \
            echo "nohup bash -c 'sleep 2 &amp;&amp; conky 2&gt;1 /dev/null &amp;'" | tee config/includes.binary/etc/skel/conky.sh
            chmod +x config/includes.binary/etc/skel/conky.sh
</code></pre>

<h1>Step Four: Dockerfile</h1>

<p><a href="https://github.com/cmotc/hoarderMediaOS/blob/master/Tutorial/HOWTO.4.DOCKERFILE.md">Standalone Chapter</a></p>

<p>Now let's make it even easier, and, as a bonus, make our install media easy to
bootstrap from any distribution where Docker can readily be installed. Docker is
a container engine and it's just a hair shy of perfect for generating and
re-generating LiveCD's. Unfortunately, it's not possible to do the very last
step with a simple "docker build" so instead we'll do everything up to that
point. Also, live-build create a number of large build artifacts, that you
probably don't want to accidentally commit and then have the hassle of cleaning
out of your git history. Docker will build all this in a container leaving your
configuration directory neat and clean. Docker is also really easy to learn to
use for simple things, at least so let's look at it in chunks.</p>

<h2>Install Dependencies:</h2>

<p>Docker containers are a kind of virtual machine-ish thing, which is awesome
because we can pare it down to pretty much exactly the stuff we need to build
the liveCD on a highly consistent environment. Docker's got a pretty simple sort
of language to it's Dockerfiles, you inherit from an existing container with
FROM, you run commands in the container with RUN. So to create a Debian Sid
container and install live-build and our supplemental software in it, start your
Dockerfile like this:</p>

<p><strong>Example Dockerfile: install dependencies</strong></p>

<pre><code>    FROM debian:sid
    RUN apt-get update
    RUN apt-get install -yq \
            apt-transport-https \
            gpgv-static \
            gnupg2 \
            bash \
            apt-utils \
            live-build \
            debootstrap \
            make \
            curl
    RUN apt-get dist-upgrade -yq #I like to do this just to be sure. BTW, this is a comment in a Dockerfile
</code></pre>

<h2>Recreate Users and Working Directory</h2>

<p>Next, since live-build requires us to run commands as both a user and the root,
we need create a user to run commans as, a home directory, and a working
directory for our configuration. To create a user with an empty home directory
and a default bash shell, add the following line to the Dockerfile.</p>

<pre><code>    RUN useradd -ms /bin/bash livebuilder
</code></pre>

<p>Now, use the ADD Dockerfile command to create the working directory you will use
to create the iso.</p>

<pre><code>    ADD . /home/livebuilder/tv-live
</code></pre>

<p>Transfer ownership of the directory to the new user before doing anything else</p>

<pre><code>    RUN chown -R livebuilder:livebuilder /home/livebuilder/tv-live
</code></pre>

<p>Become the new user</p>

<pre><code>    USER livebuilder
</code></pre>

<p>And establish the working directory.</p>

<pre><code>    WORKDIR /home/livebuilder/tv-live
</code></pre>

<p>Now, all commands will be run as the user livebuilder in the directory
/home/livebuilder/tv-live</p>

<p><strong>Example Dockerfile: set up work area</strong></p>

<pre><code>    RUN useradd -ms /bin/bash livebuilder
    ADD . /home/livebuilder/tv-live
    RUN chown -R livebuilder:livebuilder /home/livebuilder/tv-live
    USER livebuilder
    WORKDIR /home/livebuilder/tv-live
</code></pre>

<h2>Copy the Configuration Files</h2>

<p>Now that our working area is ready, we need to copy our configuration files into
the new working directory. In dockerese, copying a folder and a file works the
same way. You just use the COPY command and specify what you wish to copy. So
to copy our auto folder in it's entirity, just do:</p>

<pre><code>    COPY auto /home/livebuilder/tv-live/auto
</code></pre>

<p>Now, for some reason I'm not entirely sure of, lb init doesn't work in the
Docker container. But it seems like all lb init does, at least the way I've been
using it, is create a folder called '.build' owned by root. So instead, I just
add another little helper to the Makefile to do just that at build time.</p>

<p><strong>Example Makefile Fragment: make docker-init</strong></p>

<pre><code>    docker-init:
            mkdir -p .build
</code></pre>

<p>and to copy the Makefile, just do:</p>

<pre><code>    COPY Makefile /home/livebuilder/tv-live/Makefile
</code></pre>

<p>and add the new init helper as root and switch back to the livebuilder user.</p>

<pre><code>    USER root
    RUN make docker-init
    USER livebuilder
</code></pre>

<p><strong>Example Dockerfile: copy build files</strong></p>

<pre><code>    COPY Makefile /home/livebuilder/tv-live/Makefile
    USER root
    RUN make docker-init
    USER livebuilder
</code></pre>

<h2>Run the Pre-Build Configuration</h2>

<p>Now, run your custom make commands to prepare the configuration folder and build
directory.</p>

<p><strong>Example Dockerfile: fine-tune configuration</strong></p>

<pre><code>    RUN make config-hardened
    RUN make syncthing-repo
    RUN make i2pd-repo
    RUN make skel
    RUN make packages
</code></pre>

<p>and you're almost done!</p>

<h2>Build the Container</h2>

<p>Now you run the commands in your Dockerfile by running docker build in the
current directory</p>

<pre><code>    docker build -t tv-build .
</code></pre>

<p>Just because I can, I keep this in the Makefile under 'make docker'</p>

<h2>Run the Priveleged Part of the Build and Extract the Artifacts</h2>

<p>Finally, in order to mount /proc in our container, we must run a command as a
priveleged user in the container. That command is lb build:</p>

<p>Edit: 11/16/2017: The container also requires access to a loopback device, as
   newly reflected below.</p>

<pre><code>    docker run -i --device /dev/loop0 --name "tv-build" --privileged -t tv-build lb build
</code></pre>

<p>Specifying the --name of the container you want to run the command in will keep
you from losing track of the build artifacts when you copy them to the host
machine later.</p>

<p><strong>Example auto/build Figure 2:</strong></p>

<pre><code>    #! /usr/bin/env bash
    lb build noauto \
        "$@"
    bash
</code></pre>

<p>From the prompt, you can inspect the results of the build, and extract the build
artifacts using docker cp:</p>

<pre><code>    docker cp tv-build:/home/livebuilder/tv-live/tv-* .
</code></pre>

<p>and you now have, what I think, is a pretty great way to remaster your own live
install media.</p>

<p>Unfortunately, because this depends on using chroots as they function in a
regular GNU/Linux distribution, this means that we won't be able to run our
build in Docker on our hardened-kernel system. We can work around this, however
imperfectly, by allowing mounts in chroots</p>

<pre><code>    sudo sysctl -w kernel.grsecurity.chroot_caps=0
    sudo sysctl -w kernel.grsecurity.chroot_deny_chmod=0
    sudo sysctl -w kernel.grsecurity.chroot_deny_mknod=0
    sudo sysctl -w kernel.grsecurity.chroot_deny_mount=0
    sudo sysctl -p
    docker run -i --device /dev/loop0 --privileged -t hoarder-build make build
    sudo sysctl -w kernel.grsecurity.chroot_caps=0
    sudo sysctl -w kernel.grsecurity.chroot_deny_chmod=1
    sudo sysctl -w kernel.grsecurity.chroot_deny_mknod=1
    sudo sysctl -w kernel.grsecurity.chroot_deny_mount=1
    sudo sysctl -p
</code></pre>

<h1>Step Five: Provide a path to verify Authentic copies</h1>

<p><a href="https://github.com/cmotc/hoarderMediaOS/blob/master/Tutorial/HOWTO.5.AUTHENTICATE.md">Standalone Chapter</a></p>

<p>Like I said, we should all be careful about who we trust to assemble all our
software. Likewise, when you distribute it in binary form, it probably makes
sense to provide many ways to verify that the recipient of that copy has
obtained it authentically. To do this, you have many options, and you should
choose to use them all if possible.</p>

<h2>Compute Hashes</h2>

<p>The first step to helping your fellow enthusiast to verify the authenticity of
an image, you need to compute hashes of those images. A <em>hash function</em> takes
an arbitrary piece of data, any data will do, and creates a string of a fixed
size which is totally unique to the piece of data that was <em>hashed</em>. So when we
sha256sum our iso file, we will get a string that is unique to our iso file and
cannot be reproduced, without an exact copy of the original iso file. The tool
we should use for this is sha256sum, which computes hashes based on the Secure
Hashing Algorithm, the 256 bit version, which is used by many GNU/Linux
distributions to verify the authenticity of their distributed iso files.</p>

<p>In order to produce the sha256sum of the iso file, run the following command. It
make take a moment, especially if the file is large in size.</p>

<pre><code>    sha256sum tv-amd64.hybrid.iso
</code></pre>

<p>Once the hash is computed, it will be emitted to stdout in the form</p>

<pre><code>    86b70a74e30eec40bf129c44a8dd823c1320200825bc4222556ce1241d4863dd  tv-amd64.hybrid.iso
</code></pre>

<p>This can now be used to ensure that the file corresponds to the hash, which is
one half ot the authenticity puzzle. If you want to compute the hashes in your
Makefile, you could use something like the following snippet.</p>

<pre><code>    **Example Makefile Fragment: hash, delete empty on failure**
    hash:
            sha256sum tv-amd64.hybrid.iso &gt; \
                    tv-amd64.hybrid.iso.sha256sum || \
                    rm tv-amd64.hybrid.iso.sha256sum; \
</code></pre>

<p>Because piping the output of sha256sum will always produce a file, but if the
file to be hashed doesn't exist, the created file will be empty, we make sure
that sha256sum signals that it has completed <em>successfully</em> and if it fails, we
delete the created file.</p>

<h2>Sign Hashes</h2>

<p>Now we've got hashes to verify the iso's correspond to the hashes, but now we
need a way for the user to verify the provenance of the hashes themselves. In
order to do this, we need to sign them with a key that corresponds to some real
set of contact information. Traditionally, this has been an e-mail but maybe
something out there is better for you.</p>

<p>To get started, we need to generate a signing key. If you already have a signing
key you want to use, then you can skip this step.</p>

<p><a href="https://wiki.debian.org/Keysigning#Step_1:_Create_a_RSA_keypair">See Also: Key Generation/Distribution</a></p>

<p><a href="https://keyring.debian.org/creating-key.html">Also See Also: Key Generation</a></p>

<p>Before you do anything else, you should edit your $HOME/.gnupg/gpg.conf to not
use SHA1 as it's hashing algorithm.</p>

<pre><code>    personal-digest-preferences SHA256
    cert-digest-algo SHA256
    default-preference-list SHA512 SHA384 SHA256 SHA224 AES256 AES192 AES CAST5 ZLIB BZIP2 ZIP Uncompressed
</code></pre>

<p>Now, you'll need to start the gpg key generation procedure:</p>

<pre><code>    gpg --gen-key
</code></pre>

<p>You'll be prompted for whick key type you want to generate. RSA and RSA, the
default key type, is the one that we want. On the next prompt, you'll be
prompted to select a key size, and you should select 4096 for your signing key.
Then select a time frame for the key to be valid. For the sake of brevity, I
direct you to the second
<a href="https://keyring.debian.org/creating-key.html">link at the top of this section</a>.</p>

<p>Now that you're done with that, you've just got to get ready to share your key.
First, generate a key revocation certificate. Back it up someplace safe. You
will use it in case your private key is ever compromised to inform people that
they must disregard the compromised key and update to an uncompromised key.</p>

<pre><code>    gpg --gen-revoke ${KEY_ID} &gt; ~/.gnupg/revocation-${KEY_ID}.crt
</code></pre>

<p>Finally, share the <strong>public</strong> key with the world.</p>

<pre><code>    gpg --send-key ${KEY_ID}
</code></pre>

<p>Now that we've got our signing key, let's use it to sign the files:</p>

<pre><code>    gpg --batch --yes --clear-sign -u "$(SIGNING_KEY)" tv-amd64.hybrid.iso.sha256sum
</code></pre>

<p>After you're done, you'll have a signed copy of the hash file that looks like
this:</p>

<pre><code>    -----BEGIN PGP SIGNED MESSAGE-----
    Hash: SHA256

    86b70a74e30eec40bf129c44a8dd823c1320200825bc4222556ce1241d4863dd  tv-amd64.hybrid.iso
    -----BEGIN PGP SIGNATURE-----

    iQEzBAEBCAAdFiEEwM7uKXtf5F/2EKrG8F+F+kRsBCsFAllIqBoACgkQ8F+F+kRs
    BCubMwgAuf81nTIcmM8COY7T7RGp51ApiAMETU1tuHQbOKBKDRemgml2UZ0DNVLZ
    wCtnfErsQD8getUSpqSk07e448sCbEUYeifH8xS/6uC3JbCkITt4bDl6UdU2BXm0
    I9IkweK3d0hp5TIjs4m9fA3qVTto1v9EaUxQhREB3/do2FhqP+60ehqR3dgqLzOr
    5ueXxXCeFAHJhyvQk0EvKwvWciabqj8gY2ra5aEXE+kAJWz8mrLyK/4Q0IBwXMYm
    xPiXNctlaldqDCjsF42ronHQlHK7pg0l58Pht/kSh8ERKPyhtLGeOOrNyjcbg8/t
    HE65ErJ7ArZZJQ7KBdxFr8lzkrPsEg==
    =PrNx
    -----END PGP SIGNATURE-----
</code></pre>

<p>and can be used by anyone with your public key to assure that the hash they
are using, and thus the iso it corresponds to, came from the owner of the
corresponding private key and them alone. In order to make the signatures with
the Makefile, a fragment like the following will work. Note that we don't have
to delete failed signatures, a nonexistent file will just not produce a
signature.</p>

<pre><code>    **Example Makefile Fragment: sign the hash**
    sign:
            gpg --batch --yes --clear-sign -u "$(SIGNING_KEY)" \
                    tv-amd64.hybrid.iso.sha256sum ; \
</code></pre>

<h1>Step Six: Create torrents and Release</h1>

<p><a href="https://github.com/cmotc/hoarderMediaOS/blob/master/Tutorial/HOWTO.6.RELEASE.md">Standalone Chapter</a></p>

<p>Now we've got everything we need to responsibly share our configuration except
a means of sharing it. Fortunately, with a little trickery you can actually
reliably bootstrap some really good ways of distributing your iso file. I like
a combination of Github Releases and a cool feature of the Bittorrent protocol
known as "Web Seeds" that allow you to supplement a Peer-to-Peer swarm with an
HTTP or HTTPS source. Unfortunately, in order to make this automatic we have to
install an additional couple of dependencies. Fortunately for us, one of those
dependencies is in Go! Go is an awesome language that anyone can use.
Unfortunately for us, it's because the excellent Go software involved here isn't
quite available in Debian just yet.</p>

<h2>Install Extra Dependencies</h2>

<p>OK so first, we need to install the extra dependencies here. We'll be using the
terminal tool "mktorrent" to generate our torrent files, and we'll be using
golang to get the github-release package.</p>

<pre><code>    sudo apt-get install mktorrent golang
</code></pre>

<p>Now, set the GOPATH and run 'go get' to retrieve the package</p>

<pre><code>    export GOPATH="$HOME/.go"
    mkdir -p "$GOPATH"
    go get github.com/aktau/github-release
</code></pre>

<p>And include the GOPATH in your PATH</p>

<pre><code>    export PATH="$GOPATH:$PATH"
</code></pre>

<p>Now, generate a torrent from the file. I just added a bunch of public annouce
URLS to it, these are open trackers anyone can use. Note that we also use a
Web Seed to supplement our torrent. This is very, very important, it'll provide
a consistent source for downloads until a large enough swarm exists that it is
no longer neccessary.</p>

<pre><code>    mktorrent -a "udp://tracker.openbittorrent.com:80" \
    -a "udp://tracker.publicbt.com:80" \
    -a "udp://tracker.istole.it:80" \
    -a "udp://tracker.btzoo.eu:80/announce" \
    -a "http://opensharing.org:2710/announce" \
    -a "udp://open.demonii.com:1337/announce" \
    -a "http://announce.torrentsmd.com:8080/announce.php" \
    -a "http://announce.torrentsmd.com:6969/announce" \
    -a "http://bt.careland.com.cn:6969/announce" \
    -a "http://i.bandito.org/announce" \
    -a "http://bttrack.9you.com/announce" \
    -w https://github.com/"$(MY_ACCOUNT)"/"$(MY_ISO)"/releases/download/$(shell date +'%y.%m.%d')/tv.iso \
    tv-amd64.hybrid.iso; \
</code></pre>

<p>Awesome, now that the torrent is generated, generate a tag for the release on
github. I just use the date to tag the releases, as the point of this procedure
is to run builds frequently.</p>

<pre><code>    git tag $(date +'%y.%m.%d'); git push --tags github
</code></pre>

<p>in a Makefile, the same command will need to look like this:</p>

<pre><code>    git tag $(shell date +'%y.%m.%d'); git push --tags github
</code></pre>

<p>In order to create a Github release for that tag, you'll need to use the
program we downloaded with go get, github-release:</p>

<pre><code>    github-release release \
    --user "$(MY_ACCOUNT)" \
    --repo "$(MY_ISO)" \
    --tag $(shell date +'%y.%m.%d') \
    --name "$(MY_ISO)" \
    --description "A re-buildable OS for self-hosting. Please use the torrent if possible" \
    --pre-release ; \
</code></pre>

<p>Now we're ready to upload our built images and verification materials to the
release page. I generally upload them from smallest to largest files so to
upload the sha256 hash:</p>

<pre><code>    github-release upload --user "$(MY_ACCOUNT)" --repo "$(MY_ISO)" --tag $(shell date +'%y.%m.%d') \
            --name "$(MY_ISO)" \
            --file tv-amd64.hybrid.iso.sha256sum; \
</code></pre>

<p>And the signed sha256 hash:</p>

<pre><code>    github-release upload --user "$(MY_ACCOUNT)" --repo "$(MY_ISO)" --tag $(shell date +'%y.%m.%d') \
            --name "$(MY_ISO)" \
            --file tv-amd64.hybrid.iso.sha256sum.asc;\
</code></pre>

<p>And the torrent file:</p>

<pre><code>    github-release upload --user "$(MY_ACCOUNT)" --repo "$(MY_ISO)" --tag $(shell date +'%y.%m.%d') \
            --name "$(MY_ISO)" \
            --file tv-amd64.hybrid.iso.torrent;\
</code></pre>

<p>and finally, the bootable, Live ISO image.</p>

<pre><code>    github-release upload --user "$(MY_ACCOUNT)" --repo "$(MY_ISO)" --tag $(shell date +'%y.%m.%d') \
            --name "$(MY_ISO)" \
            --file tv-amd64.hybrid.iso;\
</code></pre>
</div>
<div id="sidebar">
<h2>Projects:</h2>

<h3>Home Network/Install Media Projects</h3>

<h4>Self Hosting Projects</h4>

<ul>
<li><a href="https://eyedeekay.github.io/apt-now/">apt-now, a layer of convenience around reprepro for hosting custom packages</a>
<ul>
<li><a href="https://github.com/eyedeekay/apt-now/">apt-now Project Repo</a></li>
</ul></li>
<li><a href="https://eyedeekay.github.io/hoarderCache-docker/">apt-cacher-ng in a docker container with experimental, https-only p2p repos preconfigured for caching</a>
<ul>
<li><a href="https://github.com/eyedeekay/hoardercache-docker/">HoarderCache-Docker Project Repo</a></li>
</ul></li>
<li><a href="https://eyedeekay.github.io/">/Not posted yet: Sharing apt-cacher-ng contents across identically controlled instances with Syncthing</a>
<ul>
<li><a href="https://github.com/eyedeekay/hoardercache-docker/">HoarderCache-Docker Example</a></li>
</ul></li>
</ul>

<h4>Install Media Projects</h4>

<ul>
<li><a href="https://eyedeekay.github.io/hoarderMediaOS/">apt-based GNU+Linux distro install media generation</a>
<ul>
<li><a href="https://github.com/eyedeekay/hoarderMediaOS/">HoaderMediaOS Project Repo</a></li>
</ul></li>
<li><a href="https://eyedeekay.github.io/kloster/">Alpine Busybox+Linux+Xen+PVM distro install media generation</a>
<ul>
<li><a href="https://github.com/eyedeekay/kloster/">Kloster Project Repo</a></li>
</ul></li>
<li><a href="https://eyedeekay.github.io/lede-docker/">LEDE Busybox+Linux install media generation</a>
<ul>
<li><a href="https://github.com/eyedeekay/lede-docker">LEDE Build Configuration Project Repo</a></li>
</ul></li>
<li><a href="https://eyedeekay.github.io/imgmaker/">Live Media generation for Allwinner tablets</a>
<ul>
<li><a href="https://github.com/eyedeekay/imgmaker">imgmaker Project Repo</a></li>
</ul></li>
</ul>

<h3>Game Development Projects</h3>

<ul>
<li><a href="https://eyedeekay.github.io/lair-web">LAIR</a>
<ul>
<li><a href="https://github.com/eyedeekay/valair">Project Repo</a></li>
</ul></li>
</ul>

<h3>Security Projects</h3>

<p><em>Coming soonish</em></p>
</div>
<div id="content">
<h1>Monero Wallet Address</h1>

<p>XMR:4BFQswB7PU43GCCLWMnQdZD6oGBmUdVYSXhrkuKeGMCMZQoVKyjw6Y6NQu3UHbWQjwYTm6Jzu5EnZc2pQgL8Wa2HUgEBVEA</p>
</div>
</body>
